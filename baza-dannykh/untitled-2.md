# Вставка записей \(insert\)

Конструктор запросов позволяет вставлять записи в базу данных. При этом конструктор избавляет вас от необходимости писать SQL запросы самостоятельно. Вы просто используете объектно ориентированные возможности PHP. А если вы используете IDE, то это существенно упростит вам жизнь благодаря автодополнению кода.

Для работы с базой данных нужно получить объект подключения к базе данных. Это можно сделать следующим образом:

```php
$connection = \Illuminate\Database\Capsule\Manager::connection();
```

Далее рассмотрим примеры вставки данных в таблицу в базе данных. В примере будет рассматриваться таблица со следующей структурой:

![&#x421;&#x442;&#x440;&#x443;&#x43A;&#x442;&#x443;&#x440;&#x430; &#x442;&#x430;&#x431;&#x43B;&#x438;&#x446;&#x44B; test\_table](../.gitbook/assets/image%20%285%29.png)

## Вставка строки

Рассмотрим пример обычной вставки строки в таблицу **test\_table**.

```php
$connection->table('test_table')->insert(
    [
        'name' => 'test name',
        'text' => 'text text text',
    ]
);
```

Этот пример кода вставит строку в базу данных. Как видите всё достаточно просто. В метод **table** подается название таблицы с которой работаем, а далее вызывается метод **insert** в который подается ассоциативный массив в котором ключем является название колонки в таблице **test\_table**, а значением является значение, которое будет вставлено.

## Вставка строки и получение идентификатора вставленной записи

В примере выше мы рассмотрели обычную вставку строки в базу данных. Но часто нам нужно вдобавок к этому получить идентификатор вставленной записи. Давайте сделаем это.

```php
$id = $connection->table('test_table')->insertGetId(
    [
        'name' => 'test name',
        'text' => 'text text text',
    ]
);
```

Как вы видите, вместо метода **insert** использовался метод **insertGetId**, а результат присваивается переменной **$id**. После выполнения этого кода в переменной **$id** будет содержаться идентификатор вставленной записи.

## Вставка нескольких строк в таблицу

Иногда есть необходимость вставить сразу много строк в таблицу в базе данных. Конструктор запросов позволяет сделать и это.

```php
$connection->table('test_table')->insert(
    [
        [
            'name' => 'test name 1',
            'text' => 'text text text 1',
        ],
        [
            'name' => 'test name 2',
            'text' => 'text text text 2',
        ],
        [
            'name' => 'test name 3',
            'text' => 'text text text 3',
        ],
    ]
);
```

Этот пример кода вставит в таблицу **test\_table** сразу 3 строки. В массиве, который передается в метод **insert** должны передаваться массивы с записями, которые необходимо вставить.

## Вставка с игнорированием ошибок

Иногда необходимо вставить запись в таблицу, но при этом проигнорировать записи с уже существующими уникальными значениями столбцов. Рассмотрим пример кода чтобы лучше понять.

```php
$connection->table('test_table')->insertOrIgnore(
    [
        [
            'id'   => 1,
            'name' => 'test name 1',
            'text' => 'text text text 1',
        ],
        [
            'id'   => 2,
            'name' => 'test name 2',
            'text' => 'text text text 2',
        ],
        [
            'id'   => 3,
            'name' => 'test name 3',
            'text' => 'text text text 3',
        ],
    ]
);
```

В таблице **test\_table** есть колонка **id**. Это первичный ключ и он должен быть уникальным. Если мы попытаемся вставить строку с существующим **id** обычным методом **insert**, то мы получим ошибку. Метод **insertOrIgnore** вставит 3 строки в таблицу только в том случае, если в ней нет строк с такими же идентификаторами. Если в таблице есть строки с id = 1, но нет строк с идентификаторами 2 и 3, то вставятся только строки с идентификаторами 2 и 3, а первая строка будет проигнорирована.

{% hint style="info" %}
Обратите внимание, что вам не нужно заботиться о защите от SQL инъекций. При выполнении запросов в конструкторе используются подготовленные запросы, благодаря чему выполнение запросов становится безопасным. Но учтите, что это не избавляет вас от необходимости делать данные безопасными при выводе из базы данных там где это необходимо.
{% endhint %}

